import collections
import sys

Origin = collections.namedtuple('Origin', 'filename position string')
Token = collections.namedtuple('Token', 'type value origin')
Node = collections.namedtuple('Node', 'type value children origin')

SYMBOLS = (
    '\\', '.', '...',
    ':',
    '+', '-', '*', '/', '%',
    '(', ')', '[', ']', ',', '=',
    '==', '<', '>', '<=', '>=', '!=',
    ';',
)

KEYWORDS = (
    'is',
    'while', 'break',
    'if', 'else',
    'and', 'or',
    'return',
)


def Lex(string, filename):
  """Given a string and name of file it was extracted from, returns a list of tokens.

  Args:
    string: string to lex.
    filename: name of file this string is from. This function does not check the validity of this value in any way.
  """
  tokens = []
  depth = 0
  s = string
  i = 0
  indent_stack = ['']

  def MakeToken(type_, value=None):
    return Token(type_, value, Origin(filename, j, s))

  while True:
    while i < len(s) and ((s[i].isspace() and (depth or s[i] != '\n')) or s[i] == '#'):
      if s[i] == '#':
        while i < len(s) and s[i] != '\n':
          i += 1
      else:
        i += 1

    j = i

    if i >= len(s):
      break
    elif s[i] == '\n':
      i += 1
      tokens.append(MakeToken('Newline'))

      while True:
        j = i
        while i < len(s) and s[i].isspace() and s[i] != '\n':
          i += 1
        if i < len(s) and s[i] == '#':
          while i < len(s) and s[i] != '\n':
            i += 1
        if i >= len(s) or not s[i].isspace():
          break
        i += 1

      if i < len(s):
        indent = s[j:i]
        if indent == indent_stack[-1]:
          pass
        elif indent.startswith(indent_stack[-1]):
          tokens.append(MakeToken('Indent'))
          tokens.append(MakeToken('Newline'))
          indent_stack.append(indent)
        elif indent in indent_stack:
          while indent != indent_stack[-1]:
            tokens.append(MakeToken('Dedent'))
            tokens.append(MakeToken('Newline'))
            indent_stack.pop()
        else:
          raise SyntaxError('Invalid indent: ' + repr(indent))

    elif s[i].isdigit() or s[i] == '.' and s[i+1:i+2].isdigit():
      while i < len(s) and s[i].isdigit():
        i += 1
      if i < len(s) and s[i] == '.':
        i += 1
        while i < len(s) and s[i].isdigit():
          i += 1
      tokens.append(MakeToken('Number', eval(s[j:i])))
    elif s.startswith(('r"', "r'", '"', "'"), i):
      raw = False
      if s[i] == 'r':
        i += 1
        raw = True
      quote = s[i:i+3] if s.startswith(('""""', "'''"), i) else s[i:i+1]
      i += len(quote)
      while not s.startswith(quote, i):
        if i >= len(s):
          raise SyntaxError("Missing quotes for: " + quote)
        i += 2 if not raw and s[i] == '\\' else 1
      i += len(quote)
      tokens.append(MakeToken('String', eval(s[j:i])))
    elif s[i].isalnum() or s[i] == '_':
      while i < len(s) and s[i].isalnum() or s[i] == '_':
        i += 1
      word = s[j:i]
      if word in KEYWORDS:
        tokens.append(MakeToken(word))
      else:
        tokens.append(MakeToken('Name', word))
    elif s.startswith(SYMBOLS, i):
      symbol = max(symbol for symbol in SYMBOLS if s.startswith(symbol, i))
      if symbol in ('(', '{', '['):
        depth += 1
      elif symbol in (')', '}', ']'):
        depth -= 1
      i += len(symbol)
      tokens.append(MakeToken(symbol))
    else:
      while i < len(s) and not s[i].isspace():
        i += 1
      raise SyntaxError("Unrecognized token: " + s[j:i])

  while indent_stack[-1] != '':
    tokens.append(MakeToken('Dedent'))
    indent_stack.pop()

  tokens.append(MakeToken('End'))

  return tokens


def Parse(string, filename):
  """Given a string and source, generates the CST (Concrete Syntax Tree).

  Arguments are semantically the same as in Lex.

  The difference between a CST and an AST (for CCL at least), is that
  CST directly mirrors the syntax and is directly generated by the parser,
  whereas the AST is generated from processing the CST.

  CST node types:

    Module

    Name
    Number
    String
    List
    Function
    Block
    Attribute
    Call

    if
    while
    break
    return
    var

    Arguments # Only found as second child of Call nodes.

    Assign

  """
  toks = Lex(string, filename)
  i = [0]

  def Peek(lookahead=0):
    return toks[i[0]+lookahead]

  def At(type_, origin=None, lookahead=0):
    if Peek(lookahead).type == type_:
      if origin:
        origin[0] = Peek(lookahead).origin
      return True

  def GetToken():
    tok = toks[i[0]]
    i[0] += 1
    return tok

  def Consume(type_, origin=None):
    if At(type_, origin):
      return GetToken()

  def Expect(type_, origin=None, error_message=None, error_origin=None):
    if not At(type_, origin):
      raise SyntaxError('Expected %s but found %s' % (type_, Peek()[0]))
    return GetToken()

  def EatExpressionDelimiters():
    while Consume('Newline') or Consume(';'):
      pass

  def Expression():
    return AssignExpression()

  def MakeNodeFromToken(token):
    return Node(token.type, token.value, [], token.origin)

  def PrimaryExpression():
    origin = [None]
    if At('Name') or At('String') or At('Number'):
      return MakeNodeFromToken(GetToken())
    elif Consume('[', origin):
      exprs = []
      while not Consume(']'):
        exprs.append(Expression())
        Consume(',')
      return Node('List', None, exprs, origin)
    elif Consume('\\', origin):
      args = []
      while At('Name'):
        args.append(GetToken().value)
        Consume(',')
      dot_origin = [None]
      if Consume('.', dot_origin):
        body = Node('return', None, [Expression()], dot_origin)
      else:
        EatExpressionDelimiters()
        body = Expression()
      return Node('Function', args, [body], origin)
    elif Consume('(', origin):
      expr = Expression()
      Expect(')', None, None, origin)
      return expr
    elif Consume('Indent', origin):
      exprs = []
      EatExpressionDelimiters()
      while not Consume('Dedent'):
        exprs.append(Expression())
        EatExpressionDelimiters()
      return Node('Block', None, exprs, origin)
    elif Consume('var', origin):
      names = []
      while At('Name'):
        names.append(GetToken().value)
      return Node('var', names, [], origin)
    elif Consume('if', origin):
      exprs = [Expression()] # test
      EatExpressionDelimiters()
      exprs.append(Expression()) # body
      EatExpressionDelimiters()
      if Consume('else'):
        EatExpressionDelimiters()
        exprs.append(Expression()) # else
      elif Peek(-1).type in (';', 'Newline'): # TODO: Find more elegant solution.
        i[0] -= 1
      return Node('if', None, exprs, origin)
    elif Consume('while', origin):
      exprs = [Expression()] # test
      EatExpressionDelimiters()
      exprs.append(Expression()) # body
      return Node('while', None, exprs, origin)
    elif Consume('return', origin):
      return Node('return', None, [Expression()], origin)
    raise SyntaxError('Expected Expression but found %s' % (Peek(),))

  def PostfixExpression():
    expr = PrimaryExpression()
    while True:
      if Consume('('):
        args = []
        while not Consume(')'):
          args.append(Expression())
          Consume(',')
        if At('\\'):
          args.append(PrimaryExpression())
        expr = Node('Call', None, [expr, Node('Arguments', None, args, expr.origin)], expr.origin)
      elif Consume('.'):
        expr = Node('Attribute', Expect('Name').value, [expr], expr.origin)
      else:
        break
    return expr

  def AssignExpression():
    expr = OrExpression()
    if Consume('='):
      return Node('Assign', None, [expr, AssignExpression()], expr.origin)
    return expr

  exprs = []
  EatExpressionDelimiters()
  while not At('End'):
    exprs.append(Expression())
    EatExpressionDelimiters()

  return Node('Module', None, exprs, exprs[0].origin if exprs else Expect('End').origin)


class Object(object):
  pass


class Nil(Object):
  pass

nil = Nil()


class Bool(Object):

  def __init__(self, value):
    self.value = value

true = Bool(True)
false = Bool(False)


class Number(Object):

  def __init__(self, value):
    self.value = value


class String(Object):

  def __init__(self, value):
    self.value = value


class List(Object):

  def __init__(self, value):
    self.value = value


class Function(Object):

  def __init__(self, scope, args, body):
    self.scope = scope
    self.args = args
    self.body = body


class Scope(object):

  def __init__(self, parent=None):
    self.parent = parent
    self.table = table

  def Declare(self, key):
    self.table[key] = nil

  def __getitem__(self, key):
    if key in self.table:
      return self.table[key]
    elif self.parent:
      return self.parent[key]
    else:
      raise KeyError(key)

  def __setitem__(self, key, value):
    assert isinstance(value, Object)
    if key in self.table:
      self.table[key] = value
    elif self.parent:
      self.parent[key] = value
    else:
      raise KeyError(key)

ROOT_SCOPE = Scope()


class Evaluator(object):

  def __init__(self):
    self.scope_stack = [ROOT_SCOPE]

  @property
  def scope(self):
    return self.scope_stack[-1]

  def Evaluate(self, node):
    if node.type == 'Module':
      for child in node.children:
        last = self.Evaluate(child)
      return last
    elif node.type == 'Name':
      return self.scope[node.value]
    elif node.type == 'Number':
      return Number(self.value)
    elif node.type == 'String':
      return String(self.value)
    elif node.type == 'List':
      return List([self.Evaluate(n) for n in node.children])
    elif node.type == 'Function':
      body, = node.children
      args = node.value
      return Function(self.scope, args, body)
    elif node.type == 'Block':
      for child in node.children:
        last = self.Evaluate(child)
      return last
    elif node.type == 'Attribute':
      owner = self.Evaluate(node.children[0])
      return getattr(owner, node.value)
    elif node.type == 'Call':
      f, args = list(map(self.Evaluate, node.children))
      if isinstance(f, Function):
        scope = Scope(self.scope)
        for name, arg in zip(node.args, args):
          scope.declare(name)
          scope[name] = arg
        self.scope_stack.append(scope)
        try:
          result = self.Evaluate(body)
        finally:
          self.scope_stack.pop()
      else:
        result = f(*args)
      return result
    else:
      raise ValueError('Unrecognized node type: ' + node.type)


if __name__ == '__main__':
  sys.stdout.write(Evaluator().Evaluate(Parse(sys.stdin.read(), '<stdin>')))
