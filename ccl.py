import collections
import sys

Origin = collections.namedtuple('Origin', 'filename position string')
Token = collections.namedtuple('Token', 'type value origin')
Node = collections.namedtuple('Node', 'type value children origin')

SYMBOLS = (
    '\\', '.', '...',
    ':',
    '+', '-', '*', '/', '%',
    '(', ')', '[', ']', ',', '=',
    '==', '<', '>', '<=', '>=', '!=',
    ';',
)

KEYWORDS = (
    'is',
    'while', 'break',
    'if', 'else',
    'and', 'or',
    'return',
)


def Lex(string, filename):
  """Given a string and name of file it was extracted from, returns a list of tokens.

  Args:
    string: string to lex.
    filename: name of file this string is from. This function does not check the validity of this value in any way.
  """
  tokens = []
  depth = 0
  s = string
  i = 0
  indent_stack = ['']

  def MakeToken(type_, value=None):
    return Token(type_, value, Origin(filename, j, s))

  while True:
    while i < len(s) and ((s[i].isspace() and (depth or s[i] != '\n')) or s[i] == '#'):
      if s[i] == '#':
        while i < len(s) and s[i] != '\n':
          i += 1
      else:
        i += 1

    j = i

    if i >= len(s):
      break
    elif s[i] == '\n':
      i += 1
      tokens.append(MakeToken('Newline'))

      while True:
        j = i
        while i < len(s) and s[i].isspace() and s[i] != '\n':
          i += 1
        if i < len(s) and s[i] == '#':
          while i < len(s) and s[i] != '\n':
            i += 1
        if i >= len(s) or not s[i].isspace():
          break
        i += 1

      if i < len(s):
        indent = s[j:i]
        if indent == indent_stack[-1]:
          pass
        elif indent.startswith(indent_stack[-1]):
          tokens.append(MakeToken('Indent'))
          tokens.append(MakeToken('Newline'))
          indent_stack.append(indent)
        elif indent in indent_stack:
          while indent != indent_stack[-1]:
            tokens.append(MakeToken('Dedent'))
            tokens.append(MakeToken('Newline'))
            indent_stack.pop()
        else:
          raise SyntaxError('Invalid indent: ' + repr(indent))

    elif s[i].isdigit() or s[i] == '.' and s[i+1:i+2].isdigit():
      while i < len(s) and s[i].isdigit():
        i += 1
      if i < len(s) and s[i] == '.':
        i += 1
        while i < len(s) and s[i].isdigit():
          i += 1
      tokens.append(MakeToken('Number', eval(s[j:i])))
    elif s.startswith(('r"', "r'", '"', "'"), i):
      raw = False
      if s[i] == 'r':
        i += 1
        raw = True
      quote = s[i:i+3] if s.startswith(('""""', "'''"), i) else s[i:i+1]
      i += len(quote)
      while not s.startswith(quote, i):
        if i >= len(s):
          raise SyntaxError("Missing quotes for: " + quote)
        i += 2 if not raw and s[i] == '\\' else 1
      i += len(quote)
      tokens.append(MakeToken('String', eval(s[j:i])))
    elif s[i].isalnum() or s[i] == '_':
      while i < len(s) and s[i].isalnum() or s[i] == '_':
        i += 1
      word = s[j:i]
      if word in KEYWORDS:
        tokens.append(MakeToken(word))
      else:
        tokens.append(MakeToken('Name', word))
    elif s.startswith(SYMBOLS, i):
      symbol = max(symbol for symbol in SYMBOLS if s.startswith(symbol, i))
      if symbol in ('(', '{', '['):
        depth += 1
      elif symbol in (')', '}', ']'):
        depth -= 1
      i += len(symbol)
      tokens.append(MakeToken(symbol))
    else:
      while i < len(s) and not s[i].isspace():
        i += 1
      raise SyntaxError("Unrecognized token: " + s[j:i])

  while indent_stack[-1] != '':
    tokens.append(MakeToken('Dedent'))
    indent_stack.pop()

  tokens.append(MakeToken('End'))

  return tokens


def Parse(string, filename):
  """Given a string and source, generates the CST (Concrete Syntax Tree).

  Arguments are semantically the same as in Lex.

  The difference between a CST and an AST (for CCL at least), is that
  CST directly mirrors the syntax and is directly generated by the parser,
  whereas the AST is generated from processing the CST.

  CST node types:

    Module

    Name
    Number
    String
    List
    Function
    Block
    Attribute
    Call

    if
    while
    break
    return
    var

    Arguments # Only found as first child of Function and second child of Call nodes.

    Assign

  """
  toks = Lex(string, filename)
  i = [0]

  def Peek(lookahead=0):
    return toks[i[0]+lookahead]

  def At(type_, origin=None, lookahead=0):
    if Peek(lookahead).type == type_:
      if origin:
        origin[0] = Peek(lookahead).origin
      return True

  def GetToken():
    tok = toks[i[0]]
    i[0] += 1
    return tok

  def Consume(type_, origin=None):
    if At(type_, origin):
      return GetToken()

  def Expect(type_, origin=None, error_message=None, error_origin=None):
    if not At(type_, origin):
      raise SyntaxError('Expected %s but found %s' % (type_, Peek()[0]))
    return GetToken()

  def EatExpressionDelimiters():
    while Consume('Newline') or Consume(';'):
      pass

  def Expression():
    return AssignExpression()

  def MakeNodeFromToken(token):
    return Node(token.type, token.value, [], token.origin)

  def PrimaryExpression():
    origin = [None]
    if At('Name') or At('String') or At('Number'):
      return MakeNodeFromToken(GetToken())
    elif Consume('[', origin):
      exprs = []
      while not Consume(']'):
        exprs.append(Expression())
        Consume(',')
      return Node('List', None, exprs, origin)
    elif Consume('\\', origin):
      args = []
      while not At('Newline') and not At('.'):
        args.append(PrimaryExpression())
        Consume(',')
      dot_origin = [None]
      if Consume('.', dot_origin):
        body = Node('return', None, [Expression()], dot_origin)
      else:
        EatExpressionDelimiters()
        body = Expression()
      return Node('Function', None, [Node('Arguments', None, args, origin), body], origin)
    elif Consume('(', origin):
      expr = Expression()
      Expect(')', None, None, origin)
      return expr
    elif Consume('Indent', origin):
      exprs = []
      EatExpressionDelimiters()
      while not Consume('Dedent'):
        exprs.append(Expression())
        EatExpressionDelimiters()
      return Node('Block', None, exprs, origin)
    elif Consume('var', origin):
      names = []
      while At('Name'):
        names.append(GetToken().value)
      return Node('var', names, [], origin)
    elif Consume('if', origin):
      exprs = [Expression()] # test
      EatExpressionDelimiters()
      exprs.append(Expression()) # body
      EatExpressionDelimiters()
      if Consume('else'):
        EatExpressionDelimiters()
        exprs.append(Expression()) # else
      elif Peek(-1).type in (';', 'Newline'): # TODO: Find more elegant solution.
        i[0] -= 1
      return Node('if', None, exprs, origin)
    elif Consume('while', origin):
      exprs = [Expression()] # test
      EatExpressionDelimiters()
      exprs.append(Expression()) # body
      return Node('while', None, exprs, origin)
    elif Consume('return', origin):
      return Node('return', None, [Expression()], origin)
    raise SyntaxError('Expected Expression but found %s' % (Peek(),))

  def PostfixExpression():
    expr = PrimaryExpression()
    while True:
      if Consume('('):
        args = []
        while not Consume(')'):
          args.append(Expression())
          Consume(',')
        if At('\\'):
          args.append(PrimaryExpression())
        expr = Node('Call', None, [expr, Node('Arguments', None, args, expr.origin)], expr.origin)
      elif Consume('.'):
        expr = Node('Attribute', Expect('Name').value, [expr], expr.origin)
      else:
        break
    return expr

  def AssignExpression():
    expr = OrExpression()
    if Consume('='):
      return Node('Assign', None, [expr, AssignExpression()], expr.origin)
    return expr

  exprs = []
  EatExpressionDelimiters()
  while not At('End'):
    exprs.append(Expression())
    EatExpressionDelimiters()

  return Node('Module', None, exprs, exprs[0].origin if exprs else Expect('End').origin)


def Evaluate(node):
  if node.type == 'Module':
    for child in node.children:
      Evaluate(child)
  elif node.type == 'Name':
    return 
  else:
    raise ValueError('Unrecognized node type: ' + node.type)


if __name__ == '__main__':
  sys.stdout.write(Translate(PRELUDE + sys.stdin.read(), '<stdin>'))
